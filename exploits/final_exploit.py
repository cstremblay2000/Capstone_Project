"""
file:       final-exploit.py
author:     Chris Tremblay <cst1465@rit.edu>
date:       03/08/2023
language:   Python3
version:    v1.0
description:
    A suite of applications to perform an MITM attack on Ignition
"""

import sys 
import argparse
import final_exploit
from os import system

# command line args
HOSTNAME_IGNITION   = None
HOSTNAME_PLC        = None

# parser strings
PARSE_DESC = "Ignition MITM Attack Suite. Capstone Project Spring 2023"
PARSE_EPIL = "Author: Chris Tremblay <cst1465@rit.edu>"

# Menu strings
MENU_STR_CAM_OVERFLOW   = "%d) CAM Overflow Attack (%s)"
MENU_STR_ARP_POISON     = "%d) ARP Poisining Attack (%s)"
MENU_STR_MODBUS_HIJACK  = "%d) Modbus Hijacking Attack (%s)"
MENU_STR_QUIT           = "%d) Quit"
MENU_ITEMS              = None # populated later
MENU_DICT               = None # populated later
MENU_RUNNING            = "Running"
MENU_NOT_RUNNING        = "Not Running"
MENU_CAM_OVERFLOW       = 0
MENU_ARP_POISON         = 1
MENU_MODBUS_HIJACK      = 2
MENU_QUIT               = 3
SELECTION_STRING        = "Enter Selection: "

# ANSI code to switch to alternate screen
ALTERNATE_SCREEN = "\u001B[?1049h"

# ANSI code to switch back to original screen
ORIGINAL_SCREEN = "\u001B[?1049l"

def to_alternate_screen():
        """
        Description:
                Switch to an alternate screen
        """
        sys.stdout.write( ALTERNATE_SCREEN )
        sys.stdout.flush()

def to_original_screen():
        """
        Description:
                Go back to main screen
        """
        sys.stdout.write( ORIGINAL_SCREEN )
        sys.stdout.flush()

def get_menu_str_items() -> list:
    """
    description:
        pull variables with prefix MENU_STR to generate list
    returns:
        the list of menu_str items
    """
    l = [ vars( final_exploit ).get(x) for x in vars( final_exploit ) \
            if( type(vars(final_exploit).get(x))==str and ( x!="__name__") \
            and ('MENU_STR' in x )) ]
    return l

def populate_menu_items():
    """
    description:
        generate menu item list and dict
    """
    # define global vars
    global MENU_ITEMS
    global MENU_DICT
    MENU_ITEMS = list()
    MENU_DICT = dict()

    # create list of menu items
    strings = get_menu_str_items()
    for string in strings:
        MENU_ITEMS.append( string )
        MENU_DICT[string] = False
    return

def parse_cli():
    """
    description:
        parse commandline args
    """
    # global variables
    global IGNITION_HOSTNAME
    global PLC_HOSTNAME

    # init parser
    parser = argparse.ArgumentParser( description=PARSE_DESC,\
                epilog=PARSE_EPIL )
    parser.add_argument( "-i", "--ignition-hostname", type=str, \
            dest = "ignition_hostname",\
            help="Hostname of Ignition Gateway server")
    parser.add_argument( "-p", "--plc-hostname", type=str, \
            dest="plc_hostname", \
            help="Hostname of PLC" )

    # parse args
    args = parser.parse_args( sys.argv[1:] )
    return

RED_PREFIX = "\033[91m"
RED_SUFFIX = "\033[0m"
def get_menu_selection() -> int:
    """
    description:
        display menu and get user selection
    returns:
        the selected item, None upon failure
    """
    looping = True
    error = False
    error_str = ""
    while( looping ):
        # print menu
        # _ = system( "clear" )
        for i in range( 0, len( MENU_ITEMS ) ):
            running = MENU_DICT[MENU_ITEMS[i]]
            if( running ):
                running = MENU_RUNNING
            else:
                running = MENU_NOT_RUNNING
            try:
                print( MENU_ITEMS[i] % (i+1, running) )
            except:
                print( MENU_ITEMS[i] % (i+1) )
        if( error ):
            print( RED_PREFIX + error_str + RED_SUFFIX )
            error = False

        # user input
        try:
            inp = input( SELECTION_STRING )
        except KeyboardInterrupt:
            return None
        finally:
            selection = None

        # error checking
        try:
            selection = int( inp )
            # selection is in bounds
            if( 0 < selection and selection <= len( MENU_ITEMS ) ):
                looping = False
            else:
                error = True
                error_str = "\tInvalid Selection. Select Number In Bounds."
        except:
            error_str = "\tInvalid Selection. Not a Valid Number." 
            error = True
    return selection-1

def input_yes_no( running: bool) -> bool:
    """
    description:
        get yes no answer 
    params:
        running -> is attack already running?
    returns:
        true, if user said yes
        false, if user said no
        None, upon some failure
    """
    while( True ):
        inp = ""
        try:
            if( running ):
                inp = input( "Stop attack? (y/n): " )
            else:
                inp = input( "Start attack? (y/n): " )
        except:
            break
        
        lower = inp.lower()
        if( len( lower ) < 0 and (lower[0] != 'n') and (lower[0] != 'y') ):
            continue
        if( lower[0] == 'y' ):
            return True
        if( lower[0] == 'n' ):
            return False
    return None

def handler_cam_overflow():
    """
    description:
        manage CAM overflow attack
    """
    print( "CAM Overflow handler. Not implemented yet" )

    # check if running
    running = MENU_DICT[MENU_STR_CAM_OVERFLOW]
    if( running ):
        print( "running" )
    else:
        print( "not running" )
    
    # start/stop attack
    yes = input_yes_no( running )
    if( yes is None ):
        print( "error" )
        return

    # if attack is running and user wants to stop it
    if( running and yes ):
        print( "stopping attack..." )
        MENU_DICT[MENU_STR_CAM_OVERFLOW] = False

    # if attack isn't running and user wants to start it
    if( not running and yes ):
        print( "starting attack..." )
        MENU_DICT[MENU_STR_CAM_OVERFLOW] = True

    if( (running and not yes) or (not running and not yes) ):
        print( "doing nothing..." )
    return

def handler_arp_poisoning():
    """
    """
    print( "ARP Poisoning handler. Not implemented yet" )
    return

def handler_modbus_hijack():
    """
    """
    print( "Modus Hijack handler. Not implmented yet" )
    return

def handler_quit():
    """
    """
    print( "Quit handler. Not implemented yet" )
    return

def main():
    """
    description:
        the driver function
    """
    looping = True
    while( looping ):
        selection = get_menu_selection()
        if( selection is None ):
            continue

        # handle selection
        if( selection == MENU_CAM_OVERFLOW ):
            handler_cam_overflow()
        elif( selection == MENU_ARP_POISON ):
            handler_arp_poisoning()
        elif( selection == MENU_MODBUS_HIJACK ):
            handler_modbus_hijack()
        elif( selection == MENU_QUIT ):
            handler_quit()
            looping = False
    return

if( __name__ == "__main__" ):
    parse_cli()
    populate_menu_items()
    to_alternate_screen()
    main()
    to_original_screen()
