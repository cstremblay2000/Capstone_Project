#!/usr/bin/env python3
"""
file:       final-exploit.py
author:     Chris Tremblay <cst1465@rit.edu>
date:       03/08/2023
language:   Python3
version:    v1.0
description:
    A suite of applications to perform an MITM attack on Ignition
"""

import sys 
import argparse
import final_exploit
from color_prefixes import *
import os
import cam_overflow
import multiprocessing as mp
import signal
import traceback

# command line args
HOSTNAME_IGNITION   = None
HOSTNAME_PLC        = None
SWITCH_MEM_SIZE     = None
DST_IP              = None
SRC_IP              = None

# parser strings
PARSE_DESC = "Ignition MITM Attack Suite. Capstone Project Spring 2023"
PARSE_EPIL = "Author: Chris Tremblay <cst1465@rit.edu>"

# Menu strings
MENU_STR_CAM_OVERFLOW   = "%d) CAM Overflow Attack (%s)"
MENU_STR_ARP_POISON     = "%d) ARP Poisining Attack (%s)"
MENU_STR_MODBUS_HIJACK  = "%d) Modbus Hijacking Attack (%s)"
MENU_STR_QUIT           = "%d) Quit"
MENU_ITEMS              = None # populated later
MENU_DICT               = None # populated later
MENU_RUNNING            = "Running"
MENU_NOT_RUNNING        = "Not Running"
MENU_CAM_OVERFLOW       = 0
MENU_ARP_POISON         = 1
MENU_MODBUS_HIJACK      = 2
MENU_QUIT               = 3
SELECTION_STRING        = "Enter Selection: "

PROCESS_DICT            = dict()

# ANSI code to switch to alternate screen
ALTERNATE_SCREEN = "\u001B[?1049h"

# ANSI code to switch back to original screen
ORIGINAL_SCREEN = "\u001B[?1049l"

def to_alternate_screen():
        """
        Description:
                Switch to an alternate screen
        """
        sys.stdout.write( ALTERNATE_SCREEN )
        sys.stdout.flush()

def to_original_screen():
        """
        Description:
                Go back to main screen
        """
        sys.stdout.write( ORIGINAL_SCREEN )
        sys.stdout.flush()

def get_menu_str_items() -> list:
    """
    description:
        pull variables with prefix MENU_STR to generate list
    returns:
        the list of menu_str items
    """
    l = [ vars( final_exploit ).get(x) for x in vars( final_exploit ) \
            if( type(vars(final_exploit).get(x))==str and ( x!="__name__") \
            and ('MENU_STR' in x )) ]
    return l

def populate_menu_items():
    """
    description:
        generate menu item list and dict
    """
    # define global vars
    global MENU_ITEMS
    global MENU_DICT
    MENU_ITEMS = list()
    MENU_DICT = dict()

    # create list of menu items
    strings = get_menu_str_items()
    for string in strings:
        MENU_ITEMS.append( string )
        MENU_DICT[string] = False
    return

def parse_cli():
    """
    description:
        parse commandline args
    """
    # global variables
    global IGNITION_HOSTNAME
    global PLC_HOSTNAME
    global SWITCH_MEM_SIZE

    # init parser
    parser = argparse.ArgumentParser( description=PARSE_DESC,\
                epilog=PARSE_EPIL )
    parser.add_argument( "-i", "--ignition-hostname", type=str, \
            dest = "ignition_hostname",\
            help="Hostname of Ignition Gateway server")
    parser.add_argument( "-p", "--plc-hostname", type=str, \
            dest="plc_hostname", \
            help="Hostname of PLC" )
    parser.add_argument( "-M", "--switch-mem", type=int,\
            dest="switch_mem",\
            help="Size of switch CAM in Kilobytes, for CAM Overflow attack. Just tells you when CAM Table is probably overflowed" )
    parser.add_argument( "-d", "--dst-ip", type=str, \
            dest="co_dst_ip", \
            help="Destination IP Address Field for ARP packet in CAM Overflow attack" )
    parser.add_argument( "-s", "--src-ip", type=str, \
            dest="co_src_ip", \
            help="Source IP Address Field for ARP packet in CAM Overflow attack")

    # parse args
    args = parser.parse_args( sys.argv[1:] )
    
    # populate args
    IGNITION_HOSTNAME   = args.ignition_hostname
    PLC_HOSTNAME        = args.plc_hostname
    SWITCH_MEM_SIZE     = args.switch_mem
    DST_IP              = args.co_dst_ip
    SRC_IP              = args.co_src_ip
    return

def get_menu_selection() -> int:
    """
    description:
        display menu and get user selection
    returns:
        the selected item, None upon failure
    """
    looping = True
    error = False
    error_str = ""
    while( looping ):
        # print menu
        for i in range( 0, len( MENU_ITEMS ) ):
            running = MENU_ITEMS[i] in PROCESS_DICT.keys()
            if( running ):
                running = GREEN_PREFIX + MENU_RUNNING + GREEN_SUFFIX
            else:
                running = RED_PREFIX + MENU_NOT_RUNNING + RED_SUFFIX
            try:
                print( MENU_ITEMS[i] % (i+1, running) )
            except:
                print( MENU_ITEMS[i] % (i+1) )
        if( error ):
            print( RED_PREFIX + error_str + RED_SUFFIX )
            error = False

        # user input
        try:
            inp = input( SELECTION_STRING )
        except KeyboardInterrupt:
            return None
        finally:
            selection = None

        # error checking
        try:
            if( inp.lower()[0] == 'q' ):
                return MENU_QUIT 

            selection = int( inp )
            # selection is in bounds
            if( 0 < selection and selection <= len( MENU_ITEMS ) ):
                looping = False
            else:
                error = True
                error_str = "\tInvalid Selection. Select Number In Bounds."
        except:
            error_str = "\tInvalid Selection. Not a Valid Number." 
            error = True
    return selection-1

def input_yes_no( running: bool ) -> bool:
    """
    description:
        get yes no answer 
    params:
        running -> is attack already running?
    returns:
        true -> if user said yes
        false -> if user said no
        None -> upon some failure
    """
    while( True ):
        inp = ""
        try:
            if( running ):
                inp = input( YELLOW_PREFIX + "Stop attack? (y/n): " + \
                            YELLOW_SUFFIX )
            else:
                inp = input( YELLOW_PREFIX + "Start attack? (y/n): " + \
                        YELLOW_SUFFIX )
        except:
            continue
        
        lower = inp.lower()
        if( len( lower ) < 0 and (lower[0] != 'n') and (lower[0] != 'y') ):
            continue
        if( lower[0] == 'y' ):
            return True
        if( lower[0] == 'n' ):
            return False
    return None

def generic_start_stop( attack: str, attack_func: callable, in_args ):
    """
    description:
        start or stop an attck
    parameters:
        attack -> the string that defines the attack
        start_func -> the function that starts the attack
        stop_func -> the function that stops the attack
    """
    # get running status
    running = attack in PROCESS_DICT

    # user input to start/stop attack
    yes = input_yes_no( running )
    if( yes is None ):
        print( RED_PREFIX + "error getting user input" + RED_SUFFIX )
        return

    # if attack is running and user wants to stop it
    if( running and yes ):
        try:
            print( YELLOW_PREFIX + "Stopping processes." + \
                YELLOW_SUFFIX )
            PROCESS_DICT[attack].terminate()
            p = PROCESS_DICT.pop( attack )
            print( YELLOW_PREFIX + "Process stopped." + YELLOW_SUFFIX )
        except Exception as e:
            traceback.print_exc()
            print( RED_PREFIX, e, RED_SUFFIX )

    # if attack isn't running and user wants to start it
    if( not running and yes ):
        print( YELLOW_PREFIX + "Starting process." + YELLOW_SUFFIX )
        p = mp.Process( target=attack_func, args=in_args )
        PROCESS_DICT[attack] = p
        PROCESS_DICT[attack].start()
        status = None
        if( p.is_alive() ):
            status = "is"
        else:
            status = "isn't"
        print( YELLOW_PREFIX + "Process %d created, and %s running." % \
            (p.pid, status) + YELLOW_SUFFIX )

    if( (running and not yes) or (not running and not yes) ):
        print( YELLOW_PREFIX + "Cancelled." + YELLOW_SUFFIX )
    return

def handler_cam_overflow():
    """
    description:
        manage turning on and off CAM overflow attack
    """
    print( YELLOW_PREFIX +  "*** CAM Overflow ***" \
            + YELLOW_SUFFIX )

    # check if we are stopping process, yes this is a smidge clunky
    if( MENU_STR_CAM_OVERFLOW in PROCESS_DICT ):
        generic_start_stop( MENU_STR_CAM_OVERFLOW, None, None )
        return

    # check and see if command line provided something
    # TODO

    # if no command line ask user for parameters
    dst_ip = None
    src_ip = None
    mem_size = None
    try:
        # messaging
        print( YELLOW_PREFIX + "Enter information src and dst fields in ARP packet, and optionally CAM table size." + YELLOW_SUFFIX )
        print( YELLOW_PREFIX + "Defaults:" + YELLOW_SUFFIX )
        print( YELLOW_PREFIX + "\tdst_ip: %s" % (cam_overflow.DST_IP) + YELLOW_SUFFIX )
        print( YELLOW_PREFIX + "\tsrc_ip: %s" % (cam_overflow.SRC_IP) + YELLOW_SUFFIX )
        print( YELLOW_PREFIX + "\tcam table size: None" + YELLOW_SUFFIX )
        print( YELLOW_PREFIX + "Enter parameters or press Ctrl-C to proceed with defaults" + YELLOW_SUFFIX )
        
        # get dest ip
        if( not DST_IP is None ):
            dst_ip = input( YELLOW_PREFIX + "Use %s as dst_ip? (Press Enter for yes, or type a new one): " + YELLOW_SUFFIX )
            if( len(dst_ip) == 0 ):
                dst_ip = DST_IP
        else:
            dst_ip = input( YELLOW_PREFIX + "dst_ip: " + YELLOW_SUFFIX )

        # get source ip
        if( not SRC_IP is None ):
            src_ip = input( YELLOW_PREFIX + "Use %s as src_ip? (Press Enter for yes, or type a new one): " + YELLOW_SUFFIX )
            if( len(src_ip) == 0 ):
                src_ip = SRC_IP
        else:
            src_ip = input( YELLOW_PREFIX + "src_ip: " + YELLOW_SUFFIX )

        # get mem size
        if( not SWITCH_MEM_SIZE is None ):
            mem_size = input( YELLOW_PREFIX + "Use %s as mem_size? (Press Enter for yes, or type a new one): " + YELLOW_SUFFIX )
            if( len(mem_size) == 0 ):
                mem_size = SWITCH_MEM_SIZE
        else:
            mem_size = input( YELLOW_PREFIX + "CAM size (Press Enter to skip): " + YELLOW_SUFFIX )

            # proess memsize before proceeding
            if( len(mem_size) == 0 ):
                mem_size = None
            try:
                mem_size = int( mem_size )
            except ValueError:
                print( RED_PREFIX + "Invalid number. Proceeding with default" + RED_SUFFIX )
                mem_size = None
    except KeyboardInterrupt:
        print( YELLOW_PREFIX + "\nProceeding with defaults" + YELLOW_SUFFIX )
        dst_ip = cam_overflow.DST_IP
        src_ip = cam_overflow.SRC_IP
        mem_size = None
    except Exception as e:
        print( RED_PREFIX + "\n" + str(e) + ". Proceeding with defaults" + RED_SUFFIX )
        dst_ip = cam_overflow.DST_IP
        src_ip = cam_overflow.SRC_IP
        mem_size = None
    finally: 
        generic_start_stop( \
            MENU_STR_CAM_OVERFLOW, \
            cam_overflow.cam_overflow, \
            (dst_ip, src_ip, mem_size ) \
        )
    return

def handler_arp_poisoning():
    """
    description:
        manage turning on and off arp poisoning attack
    """
    print( YELLOW_PREFIX + "ARP Poisoning handler. Not implemented yet" \
            + YELLOW_SUFFIX )
    generic_start_stop(\
            MENU_STR_ARP_POISON,\
            print,\
            print\
    )
    return

def handler_modbus_hijack():
    """
    description:
        manage turning on and off modbus hijacking attack
    """
    print( YELLOW_PREFIX + "Modus Hijack handler. Not implmented yet"\
            + YELLOW_SUFFIX )
    generic_start_stop(\
            MENU_STR_MODBUS_HIJACK,\
            print,\
            print\
    )               
    return

def handler_quit():
    """
    description:
        stop all processes and exit cleanly
    """
    print( "Quit handler. Not implemented yet" )
    return

def main():
    """
    description:
        the driver function
    """
    looping = True
    while( looping ):
        selection = get_menu_selection()
        if( selection is None ):
            continue

        # handle selection
        if( selection == MENU_CAM_OVERFLOW ):
            handler_cam_overflow()
        elif( selection == MENU_ARP_POISON ):
            handler_arp_poisoning()
        elif( selection == MENU_MODBUS_HIJACK ):
            handler_modbus_hijack()
        elif( selection == MENU_QUIT ):
            handler_quit()
            looping = False
    return

if( __name__ == "__main__" ):
    parse_cli()
    populate_menu_items()
    signal.signal( signal.SIGCHLD, signal.SIG_IGN )
    #to_alternate_screen()
    main()
    #to_original_screen()
