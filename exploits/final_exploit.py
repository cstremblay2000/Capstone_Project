"""
file:       final-exploit.py
author:     Chris Tremblay <cst1465@rit.edu>
date:       03/08/2023
language:   Python3
version:    v1.0
description:
    A suite of applications to perform an MITM attack on Ignition
"""

import sys 
import argparse
import final_exploit

# command line args
HOSTNAME_IGNITION   = None
HOSTNAME_PLC        = None

# flags for which attacks are running
RUNNING_CAM_OVERFLOW    = False
RUNNING_ARP_POISON      = False
RUNNING_MODBUS_HIJACK   = False

# parser strings
PARSE_DESC = "Ignition MITM Attack Suite. Capstone Project Spring 2023"
PARSE_EPIL = "Author: Chris Tremblay <cst1465@rit.edu>"

# Menu strings
MENU_STR_CAM_OVERFLOW   = "%d) CAM Overflow Attack (%s)"
MENU_STR_ARP_POISON     = "%d) ARP Poisining Attack (%s)"
MENU_STR_MODBUS_HIJACK  = "%d) Modbus Hijacking Attack (%s)"
MENU_STR_QUIT           = "%d) Quit"
MENU_ITEMS              = None # populated later
MENU_DICT               = None # populated later
MENU_RUNNING            = "Running"
MENU_NOT_RUNNING        = "Not Running"
MENU_CAM_OVERFLOW       = 0
MENU_ARP_POISON         = 1
MENU_MODBUS_HIJACK      = 2
MENU_QUIT               = 3
SELECTION_STRING        = "Enter Selection: "

def get_menu_str_items() -> list:
    """
    description:
        pull variables with prefix MENU_STR to generate list
    returns:
        the list of menu_str items
    """
    l = [ vars( final_exploit ).get(x) for x in vars( final_exploit ) \
            if( type(vars(final_exploit).get(x))==str and ( x!="__name__") \
            and ('MENU_STR' in x )) ]
    print( l )
    return l

def populate_menu_items():
    """
    description:
        generate menu item list and dict
    """
    # define global vars
    global MENU_ITEMS
    global MENU_DICT
    MENU_ITEMS = list()
    MENU_DICT = dict()

    # create list of menu items
    strings = get_menu_str_items()
    for string in strings:
        MENU_ITEMS.append( string )
        MENU_DICT[string] = False
    return

def parse_cli():
    """
    description:
        parse commandline args
    """
    # global variables
    global IGNITION_HOSTNAME
    global PLC_HOSTNAME

    # init parser
    parser = argparse.ArgumentParser( description=PARSE_DESC,\
                epilog=PARSE_EPIL )
    parser.add_argument( "-i", "--ignition-hostname", type=str, \
            dest = "ignition_hostname",\
            help="Hostname of Ignition Gateway server")
    parser.add_argument( "-p", "--plc-hostname", type=str, \
            dest="plc_hostname", \
            help="Hostname of PLC" )

    # parse args
    args = parser.parse_args( sys.argv[1:] )
    return

RED_PREFIX = "\033[91m"
RED_SUFFIX = "\033[0m"
def get_menu_selection() -> int:
    """
    description:
        display menu and get user selection
    returns:
        the selected item, None upon failure
    """
    looping = True
    error = False
    error_str = ""
    while( looping ):
        # print menu
        for i in range( 0, len( MENU_ITEMS ) ):
            running = MENU_DICT[MENU_ITEMS[i]]
            if( running ):
                running = MENU_RUNNING
            else:
                running = MENU_NOT_RUNNING
            try:
                print( MENU_ITEMS[i] % (i+1, running) )
            except:
                print( MENU_ITEMS[i] % (i+1) )
        if( error ):
            print( RED_PREFIX + error_str + RED_SUFFIX )
            error = False

        # user input
        try:
            inp = input( SELECTION_STRING )
        except KeyboardInterrupt:
            return None
        finally:
            selection = None

        # error checking
        try:
            selection = int( inp )
            # selection is in bounds
            if( 0 < selection and selection <= len( MENU_ITEMS ) ):
                looping = False
            else:
                error = True
                error_str = "\tInvalid Selection. Select Number In Bounds."
        except:
            error_str = "\tInvalid Selection. Not a Valid Number." 
            error = True
    return selection

def main():
    """
    description:
        the driver function
    """
    looping = True
    while( looping ):
        selection = get_menu_selection()
        if( selection is None ):
            break
    return

if( __name__ == "__main__" ):
    parse_cli()
    populate_menu_items()
    print( MENU_ITEMS, MENU_DICT )
    main()
